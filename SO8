#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <dirent.h>
#include <string.h>

typedef struct {
    unsigned char red;
    unsigned char green;
    unsigned char blue;
} Pixel;

void processRegularFile(const char *inputFile, const char *outputDir) {
    FILE *input = fopen(inputFile, "r");
    if (input == NULL) {
        perror("Error opening file");
        return;
    }

    char outputFileName[256];
    snprintf(outputFileName, sizeof(outputFileName), "%s/%s_statistica.txt", outputDir, inputFile);

    FILE *output = fopen(outputFileName, "w");
    if (output == NULL) {
        perror("Error creating output file");
        fclose(input);
        return;
    }

    fclose(input);
    fclose(output);
}

void processBMPFile(const char *inputFile, const char *outputDir) {
    FILE *input = fopen(inputFile, "rb");
    if (input == NULL) {
        perror("Error opening BMP file");
        return;
    }

    fseek(input, 18, SEEK_SET);
    int imageWidth, imageHeight;
    fread(&imageWidth, sizeof(int), 1, input);
    fread(&imageHeight, sizeof(int), 1, input);

    Pixel **imageData = (Pixel **)malloc(imageHeight * sizeof(Pixel *));
    for (int i = 0; i < imageHeight; ++i) {
        imageData[i] = (Pixel *)malloc(imageWidth * sizeof(Pixel));
        fread(imageData[i], sizeof(Pixel), imageWidth, input);
    }

    fclose(input);

    for (int i = 0; i < imageHeight; ++i) {
        for (int j = 0; j < imageWidth; ++j) {
            int red = imageData[i][j].red;
            int green = imageData[i][j].green;
            int blue = imageData[i][j].blue;

            int gray = (int)(0.299 * red + 0.587 * green + 0.114 * blue);

            imageData[i][j].red = (unsigned char)gray;
            imageData[i][j].green = (unsigned char)gray;
            imageData[i][j].blue = (unsigned char)gray;
        }
    }

    FILE *output = fopen(inputFile, "wb");
    if (output == NULL) {
        perror("Error opening output BMP file");
        return;
    }

    fseek(output, 18, SEEK_SET);
    fwrite(&imageWidth, sizeof(int), 4, output);
    fwrite(&imageHeight, sizeof(int), 4, output);

    for (int i = 0; i < imageHeight; ++i) {
        fwrite(imageData[i], sizeof(Pixel), imageWidth, output);
        free(imageData[i]);
    }
    free(imageData);

    fclose(output);
}

void processDirectory(const char *inputDir, const char *outputDir) {
    DIR *dir;
    struct dirent *entry;

    dir = opendir(inputDir);
    if (dir == NULL) {
        perror("Error opening directory");
        return;
    }

    while ((entry = readdir(dir)) != NULL) {
        char inputFile[256];
        snprintf(inputFile, sizeof(inputFile), "%s/%s", inputDir, entry->d_name);

        if (entry->d_type == DT_REG) {
            if (strstr(entry->d_name, ".bmp") != NULL) {
                pid_t pid = fork();
                if (pid == 0) {
                    processBMPFile(inputFile, outputDir);
                    exit(EXIT_SUCCESS);
                }
                wait(NULL);
            } else {
                pid_t pid = fork();
                if (pid == 0) {
                    processRegularFile(inputFile, outputDir);
                    exit(EXIT_SUCCESS);
                }
                int linesWritten = 0; // Placeholder for the number of lines written
                write(/* pipe */, &linesWritten, sizeof(int));
                exit(EXIT_SUCCESS);
            }
        } else if (entry->d_type == DT_DIR && strcmp(entry->d_name, ".") != 0 && strcmp(entry->d_name, "..") != 0) {
            pid_t pid = fork();
            if (pid == 0) {
                processDirectory(inputFile, outputDir);
                exit(EXIT_SUCCESS);
            }
            wait(NULL);
        }
    }

    closedir(dir);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        printf("Usage: %s <input_directory> <output_directory>\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    char *inputDir = argv[1];
    char *outputDir = argv[2];

    processDirectory(inputDir, outputDir);

    return 0;
